# P10_PythonNumpy通用函数

#### 这里是Python数据分析学习的第十篇笔记
本文包括了Numpy的通用函数，数据处理，线性代数，随机数生成

---
## 通用函数
通用函数(ufunc)是一种对ndarray中的数据实行元素级运算的函数

```
>>> arr = np.arange(10)
>>> arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

### 一元ufunc
函数|说明
---|---
abs、fabs |  计算整数、浮点数或复数的绝对值。对于非复数值，可以使用更快的fabs。
sqrt | 计算各元素的平方根。相当于`arr ** 0.5`
square | 计算各元素的平方。相当于 `arr ** 2`
exp | 计算各元素的指数e^x
log，log10，log2，log1p | 分别为自然对数(底数为e)、底数为10的log、底数为2的log、log（1+ P)
sign | 计算各元素正负号，1（正数），0（零），-1（负数）
ceil | 计算各元素的ceiling值，即大于等于该值的最小整数。
floor | 计算各元素的floor值，即小于等于该值的最大整数。
rint | 将各元素值四舍五入到最接近的整数，保留dtype。
modf | 将数组的小数和整数部分以两个独立数组的形式返回。
isnan | 返回布尔型数组，表示哪些值是NaN（非数字）。
isfinite/isinf | 返回布尔型数组，表示哪些元素是有穷的（非inf，非NaN）或那些是无穷的。
cos,cosh,sin,sinh,tan,tanh | 普通型和双曲型三角函数。
arccos,arccosh,arcsin,arcsinh,asrtan,arctanh | 反三角函数。
logical_not | 计算各元素的not x的真值，相当于-arr。

```
>>> np.sqrt(arr)
array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
        2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])

>>>np.exp(arr)
array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,
         2.00855369e+01,   5.45981500e+01,   1.48413159e+02,
         4.03428793e+02,   1.09663316e+03,   2.98095799e+03,
         8.10308393e+03]
         
```

```
>>> arr = randn(7) * 5
>>> arr
array([-6.12731998,  3.58316478,  5.86205287,  2.07906638, -2.22893385,
       -0.16603383, -2.63364759])
       
>>> np.modf(arr)
(array([-0.12731998,  0.58316478,  0.86205287,  0.07906638, -0.22893385,
        -0.16603383, -0.63364759]), 
array([-6.,  3.,  5.,  2., -2., -0., -2.]))
        
```
### 二元ufunc

函数 | 说明
--- | ---
add | 将数组中的元素对应相加。
subtract | 第一个数组的元素减去第二个的元素。
multiply | 数组元素相乘。
divide、floor_divide |  除法，或向下整除法（丢弃余数）。
power | 第一个数组中的元素A，第二个数组中的元素B，返回A的B次方。
maximum、fmax | 返回两个数组中较大值组成的数组。fmax忽略NaN。
minimum,fmin | 同上，返回较小值。
mod | 求模，即求除法的余数。
copysign | 第二个数组的符号，复制给第一个数组。
greater、greater\_equal、less、less\_equal、equal、not\_euqal | 元素级比较运算，最终产生布尔型数组，相当于>、>=、<、<=、==、!=。
logical\_and、logical\_or、logical\_xor | 元素级真值运算，相当于&，|，^。


```
x = randn(8)
y = randn(8)
x
array([ 2.15572444, -1.09296843,  0.86194306, -1.1627926 ,  0.33726016,
        1.67029335,  1.14962445, -1.53991329])

y
array([ 1.21160848, -2.48738428,  0.24921197,  0.41083697,  1.07566221,
        0.17253891,  0.88745442, -1.31463781])
        

np.maximum(x, y)
array([ 2.15572444, -1.09296843,  0.86194306,  0.41083697,  1.07566221,
        1.67029335,  1.14962445, -1.31463781])
```

---
## 数据处理
### 向量化的处理
向量化计算是一种特殊的并行计算的方式,相比于一般程序在同一时间只执行一个操作的方式,它可以在同一时间执行多次操作,通常是对不同的数据执行同样的一个或一批指令,或者说把指令应用于一个数组/向量。

首先生成两个数组，对其进行处理
```
>>> points = np.arange(-5, 5, 0.01) # 1000 equally spaced points
>>> xs, ys = np.meshgrid(points, points)
>>> ys
array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ..., 
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])

```
计算`√x^2+y^2`的结果，并调用`matplotlib`库实现数据可视化
```
>>> import matplotlib.pyplot as plt
>>> z = np.sqrt(xs ** 2 + ys ** 2)
>>> z
>>> plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()
>>> plt.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values")
```

### 将条件逻辑表达为数组运算
根据不同的条件，取不同数组的值

首先利用python的原生功能进行处理

```
>>> xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
>>> yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
>>> cond = np.array([True, False, True, True, False])

>>> result = [(x if c else y)
          for x, y, c in zip(xarr, yarr, cond)]
>>> result
```
> 缺点：  
 1、对大型数组的处理不是非常快；  
 2、无法应用于多维数组；  
 3、产生误差

使用numpy中的where函数可以轻松地完成这一功能

```
>>> result = np.where(cond, xarr, yarr)
>>> result
array([ 1.1,  2.2,  1.3,  1.4,  2.5])
```
> 三个数组的维度必须保持一致

除此以外也可以直接在where语句中使用判断语句

```
>>> arr = randn(4, 4)
>>> arr
array([[-0.41218305, -0.39326832,  0.90531324, -0.09763844],
       [-0.01755197,  0.43984922, -1.40886581,  1.86415657],
       [ 0.3001408 , -0.99959739, -1.66799863, -0.91394673],
       [ 1.68092356,  0.05727819, -0.29079264, -0.42105571]])
       
>>> np.where(arr > 0, 2, -2)
array([[-2, -2,  2, -2],
       [-2,  2, -2,  2],
       [ 2, -2, -2, -2],
       [ 2,  2, -2, -2]])
       
>>> np.where(arr > 0, 2, arr) # set only positive values to 2

Out[20]:
array([[-0.41218305, -0.39326832,  2.        , -0.09763844],
       [-0.01755197,  2.        , -1.40886581,  2.        ],
       [ 2.        , -0.99959739, -1.66799863, -0.91394673],
       [ 2.        ,  2.        , -0.29079264, -0.42105571]])
```

当需要使用双条件判断时，在纯python下：

```
result = []
for i in range(n):
    if cond1[i] and cond2[i]:
        result.append(0)
    elif cond1[i]:
        result.append(1)
    elif cond2[i]:
        result.append(2)
    else:
        result.append(3)
```

在numpy下：
```
np.where(cond1 & cond2, 0,
         np.where(cond1, 1,
                  np.where(cond2, 2, 3)))
```
> 利用where语句的嵌套使用可实现多条件判断

也可以换成一种更加高效的写法：
```
result = 1 * cond1 + 2 * cond2 + 3 * -(cond1 | cond2)
```
> 将数组的每个元素都看作0和1

### 数学和统计学方法
利用numpy内置的函数可以轻松地求得很多数学和统计学的特征值


方法 | 说明
---|---
sum | 将数组中全部或某轴向的元素求和。零长度的数组的sum为0
mean | 算术平均数。零长度的数组的mean为NaN
std、var | 分别为标准差和方差，自由度可调 (默认为n)
min、max | 最大值和最小值
argmin、argmax | 分别为最大和最小元素的索引
cumsum | 所有元素的累计和
cumprod | 所有元素的累计积

> cumsum()和sumprod()方法不聚合，调用时需要指明方向(0代表纵向、1代表横向)且最后返回一个数组

```
>>> arr = np.random.randn(5, 4) # 标准正态分布数据
array([[ 0.28698302, -1.36734831, -0.69602196, -2.37841245],
       [-0.69590225,  0.46331672, -0.44039378, -0.4049454 ],
       [ 0.3324774 , -0.73734868, -0.76413838, -1.80569051],
       [ 1.05695026,  0.24603825,  0.04628055, -0.48680929],
       [-0.42093548, -0.53088141,  0.58320918, -0.29718718]])

>>> arr.mean()
>>> np.mean(arr)
-0.40053798581096939

>>> arr.mean(axis=1)
array([-1.03869992, -0.26948118, -0.74367504,  0.21561494, -0.16644873])

>>> arr.sum()
-8.010759716219388
>>> arr.sum(0)
array([ 0.55957295, -1.92622344, -1.2710644 , -5.37304483])
```

```
>>> arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
       
>>> arr.cumsum(0)
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]], dtype=int32)
       
>>> arr.cumprod(1)
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]], dtype=int32)

```
这些方法同样可以用于布尔型数组
```
>>> arr = randn(100)
>>> (arr > 0).sum() # 正值的数量
50
```
any()和all()常常应用于布尔型数组，用于判断元素是否为真

any()判断是否存在真值，all()判断是否全为真值

```
>>> bools = np.array([False, False, True, False])
>>> bools.any()
True

>>> bools.all()
False
```

### 排序
在numpy中通过sort()方法实现数组的排序
```
>>> arr = randn(8)
>>> arr
array([-0.26696354,  0.60987225,  0.28434102, -0.18562421, -1.36858262,
        0.37802932,  0.80443246,  0.87176103])

>>> arr.sort()
>>> arr
array([-1.36858262, -0.26696354, -0.18562421,  0.28434102,  0.37802932,
        0.60987225,  0.80443246,  0.87176103])
```

对于多维数组，sort()可以在任意维度上进行排序

```
>>> arr = randn(5, 3)
>>> arr
array([[ 0.67005596, -0.28189514,  1.38070508],
       [ 0.36696489,  1.53393067,  0.08574071],
       [ 0.6338514 , -0.63206587,  0.0401381 ],
       [ 0.97142089,  0.37639292, -0.26640206],
       [ 0.56462208,  0.19779032,  1.47765862]])
       
>>> arr.sort(1)
>>> arr
array([[-0.28189514,  0.67005596,  1.38070508],
       [ 0.08574071,  0.36696489,  1.53393067],
       [-0.63206587,  0.0401381 ,  0.6338514 ],
       [-0.26640206,  0.37639292,  0.97142089],
       [ 0.19779032,  0.56462208,  1.47765862]])
```
> 调用sort()方法会直接改变原数组，如果想保持原数组不变可以将结果赋值给其他变量

可以利用排序求分位数
```
>>> large_arr = randn(1000)
>>> large_arr.sort()
>>> large_arr[int(0.05 * len(large_arr))] # 5%分位数
-1.6145087874748485
```

### 唯一化以及其他的集合逻辑
numpy中提供的数组的集合运算

方法 | 说明 
---|---
unique(x) | 计算x中的唯一元素，并返回有序结果
intersect1d(x,y) | 计算x和y中的公共元素，并返回有序结果
union1d(x,y) | 计算x和y的并集，并返回有序结果
in1d(x,y) | 得到一个表示"x的元素是否包含于y"的布尔型数组
setdiff1d(x,y) | 集合的差，即元素在x中且不在y中
setxor1d(x,y) | 集合的对称差，即存在于一个数组中但不同时存在于两个数组中的元素


找出数组中唯一的值，并返回排序的结果
```
>>> names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
>>> np.unique(names)
array(['Bob', 'Joe', 'Will'], 
      dtype='<U4')
      
>>> ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])
>>> np.unique(ints)
array([1, 2, 3, 4])
```
> 在纯python中也可以使用 `sorted(set(names))` 达到这个效果

使用in1d()方法来测试一个数组的成员是否在另一个数组中，返回一个数组
```
>>> values = np.array([6, 0, 0, 3, 2, 5, 6])
>>> np.in1d(values, [2, 3, 6])
array([ True, False, False,  True,  True, False,  True], dtype=bool)
```

---

## 线性代数
以下是常用的numpy.linalg函数
函数 | 说明
--- | --- 
diag | 以一维数组的形式返回方阵的对角线(或非对角线)元素，或将一维数组转化为方阵(非对角线元素为0)
dot | 矩阵乘法
trace | 计算对角线元素的和
det | 计算矩阵行列式
eig | 计算方阵的特征值和特征向量
inv | 计算方阵的逆 
pinv | 计算矩阵的`Moore-Penrose`伪逆
qr | 计算QR分解
svd | 计算奇异值分解(SVD)
solve | 解线性方程组`Ax = b`,其中A为一个方阵
lstsq | 计算`Ax = b`的最小二乘解
